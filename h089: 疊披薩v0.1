/*
https://zerojudge.tw/ShowProblem?problemid=h089

琛琛很喜歡吃披薩，但是調皮的承恩活動長，在某次的披薩聚會中，把琛琛最喜歡吃的30吋納豆口味披薩壓在了另外N−1片都比它小，由上往下尺寸遞增的披薩下面。這個時候，該披薩和因為披薩滲油太誇張，原本的披薩盒A快破了，第二個披薩盒B也因為意外不適合長放，只適合暫時放著，導致琛琛必須要把披薩移動到最後一個披薩盒C當中，所以她想要把上面兩片披薩但是避免披薩彼此湖再一起或是把料打翻，他在移動上方披薩時必須一次拿一片，只能拿該疊最上面的那一片。

你可以告訴琛琛，當披薩數N為多少時，要怎麼移動，才可以花最少步數把所有披薩原封不動從A放到C嗎?

*/
#include <iostream>
using namespace std;
void Hanoi(int n, char A, char B, char C);
int main()
{
  int n;
  cin >> n;
  Hanoi(n, 'A', 'B', 'C');
}
void Hanoi(int n, char A, char B, char C)
{
  if(n == 1) cout << "from " << A << " to " << C << endl;
  else
  {
    Hanoi(n-1, A, C, B);
    cout << "from " << A << " to " << C << endl;
    Hanoi(n-1, B, A, C);
  }
}
//get  NA (score:90%) 
//應該是跑的時間太久害的 我覺得我要學dynamic programming的技巧
